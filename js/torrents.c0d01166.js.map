{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/plugins/vue-event-bus.js","webpack:///external \"webtorrent\"","webpack:///./utils/resolvers/torrents/torrentsResolver.js","webpack:///./utils/resolvers/system/deviceResolver.js","webpack:///./utils/states/deviceStates.js","webpack:///./src/torrents.js","webpack:///./utils/states/processStates.js","webpack:///./utils/resolvers/app/appResolver.js","webpack:///./utils/resolvers/app/index.js","webpack:///./utils/resolvers/system/processResolver.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","EventBus","Vue","$bus","require","TORRENTS_EVENT","TORRENTS_PARSE","TORRENTS_START","TORRENTS_CLEAR","TORRENTS_PROGRESS","TorrentsResolver","torrents_id","torrents_file_content","runInRenderer","electron","_sendTorrentsWindowEvent","file_index","payload","runOnPlatform","console","log","AppResolver","broadcastEvent","callback","ipcRenderer","on","e","TorrentsWindow","runInMain","ipcMain","handle","channel","token","Promise","resolve","event_token","getWindow","webContents","send","response","invoke","uuid","runOnWeb","isWeb","runOnDesktop","isDesktop","webCallback","desktopCallback","process","path","rimraf","WebTorrent","ParseTorrent","Torrents","this","torrent_client","torrentPort","Math","floor","random","torrents_parsed","torrents_servers","torrents_instances","torrents_progress_watchers","torrent_parsed","Buffer","_sendToConsole","_saveTorrentParsed","_sendError","message","error","_getTorrentParsed","_clearTorrentInstance","add","_getTorrentFilepath","torrent","_saveTorrentInstance","file","_getTorrentFile","files","forEach","deselect","pieces","select","_startPiece","_endPiece","Error","_clearTorrentProgressWatcher","_saveTorrentProgressWatcher","_getTorrentInstance","speed","downloadSpeed","seeding","uploadSpeed","progress","downloaded","emitTorrentProgressWatcher","server","createServer","_saveTorrentServer","listen","url","address","port","_getTorrentServer","close","destroy","setInterval","join","remote","app","getPath","meta","build","appId","undefined","clearInterval","text","parse","stringify","TorrentsInstance","resolveTorrentParseEvent","parseTorrentFromBuffer","resolveTorrentStartEvent","startTorrentForFile","startTorrentProgressWatcher","startTorrentServer","resolveTorrentClearEvent","clearTorrent","isMain","type","isRenderer","APP_ABOUT","APP_BROADCAST","APP_DEVTOOLS_MAIN","APP_DEVTOOLS_TORRENT","runInProcess","showAboutPanel","AppWindow","showDevTools","TorrentWindow","AppWindows","appResolver","mainCallback","rendererCallback"],"mappings":"2BACE,SAASA,EAAqBC,GAQ7B,IAPA,IAMIC,EAAUC,EANVC,EAAWH,EAAK,GAChBI,EAAcJ,EAAK,GACnBK,EAAiBL,EAAK,GAIHM,EAAI,EAAGC,EAAW,GACpCD,EAAIH,EAASK,OAAQF,IACzBJ,EAAUC,EAASG,GAChBG,OAAOC,UAAUC,eAAeC,KAAKC,EAAiBX,IAAYW,EAAgBX,IACpFK,EAASO,KAAKD,EAAgBX,GAAS,IAExCW,EAAgBX,GAAW,EAE5B,IAAID,KAAYG,EACZK,OAAOC,UAAUC,eAAeC,KAAKR,EAAaH,KACpDc,EAAQd,GAAYG,EAAYH,IAG/Be,GAAqBA,EAAoBhB,GAE5C,MAAMO,EAASC,OACdD,EAASU,OAATV,GAOD,OAHAW,EAAgBJ,KAAKK,MAAMD,EAAiBb,GAAkB,IAGvDe,IAER,SAASA,IAER,IADA,IAAIC,EACIf,EAAI,EAAGA,EAAIY,EAAgBV,OAAQF,IAAK,CAG/C,IAFA,IAAIgB,EAAiBJ,EAAgBZ,GACjCiB,GAAY,EACRC,EAAI,EAAGA,EAAIF,EAAed,OAAQgB,IAAK,CAC9C,IAAIC,EAAQH,EAAeE,GACG,IAA3BX,EAAgBY,KAAcF,GAAY,GAE3CA,IACFL,EAAgBQ,OAAOpB,IAAK,GAC5Be,EAASM,EAAoBA,EAAoBC,EAAIN,EAAe,KAItE,OAAOD,EAIR,IAAIQ,EAAmB,GAKnBhB,EAAkB,CACrB,SAAY,GAGTK,EAAkB,GAGtB,SAASS,EAAoB1B,GAG5B,GAAG4B,EAAiB5B,GACnB,OAAO4B,EAAiB5B,GAAU6B,QAGnC,IAAIC,EAASF,EAAiB5B,GAAY,CACzCK,EAAGL,EACH+B,GAAG,EACHF,QAAS,IAUV,OANAf,EAAQd,GAAUW,KAAKmB,EAAOD,QAASC,EAAQA,EAAOD,QAASH,GAG/DI,EAAOC,GAAI,EAGJD,EAAOD,QAKfH,EAAoBM,EAAIlB,EAGxBY,EAAoBO,EAAIL,EAGxBF,EAAoBQ,EAAI,SAASL,EAASM,EAAMC,GAC3CV,EAAoBW,EAAER,EAASM,IAClC3B,OAAO8B,eAAeT,EAASM,EAAM,CAAEI,YAAY,EAAMC,IAAKJ,KAKhEV,EAAoBe,EAAI,SAASZ,GACX,qBAAXa,QAA0BA,OAAOC,aAC1CnC,OAAO8B,eAAeT,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DpC,OAAO8B,eAAeT,EAAS,aAAc,CAAEe,OAAO,KAQvDlB,EAAoBmB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQlB,EAAoBkB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,kBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKxC,OAAOyC,OAAO,MAGvB,GAFAvB,EAAoBe,EAAEO,GACtBxC,OAAO8B,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOlB,EAAoBQ,EAAEc,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRtB,EAAoB0B,EAAI,SAAStB,GAChC,IAAIM,EAASN,GAAUA,EAAOiB,WAC7B,WAAwB,OAAOjB,EAAO,YACtC,WAA8B,OAAOA,GAEtC,OADAJ,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASgB,EAAQC,GAAY,OAAO9C,OAAOC,UAAUC,eAAeC,KAAK0C,EAAQC,IAGzG5B,EAAoB6B,EAAI,cAExB,IAAIC,EAAaC,OAAO,gBAAkBA,OAAO,iBAAmB,GAChEC,EAAmBF,EAAW3C,KAAKsC,KAAKK,GAC5CA,EAAW3C,KAAOf,EAClB0D,EAAaA,EAAWG,QACxB,IAAI,IAAItD,EAAI,EAAGA,EAAImD,EAAWjD,OAAQF,IAAKP,EAAqB0D,EAAWnD,IAC3E,IAAIU,EAAsB2C,EAM1B,OAFAzC,EAAgBJ,KAAK,CAAC,EAAE,kBAEjBM,I,6ECvJT,kDAGayC,EAAW,IAAIC,OAG5BA,OAAIpD,UAAUqD,KAAOF,G,yDCNrB9B,EAAOD,QAAUkC,QAAQ,e,gVCYZC,EAAiB,iBACjBC,EAAiB,iBACjBC,EAAiB,iBACjBC,EAAiB,iBACjBC,EAAoB,oBAEZC,E,mUAU8C,GAAtCC,E,EAAAA,YAAaC,E,EAAAA,sB,kBAC/BC,eAAa,yDAAC,WAAMC,GAAN,0GACnB,EAAKC,yBAAyBD,EAAUR,EAAgB,CAACK,cAAaC,2BADnD,2CAAD,wD,0VAcgC,GAA3BD,E,EAAAA,YAAaK,E,EAAAA,W,kBAC/BH,eAAa,yDAAC,WAAMC,GAAN,0GACnB,EAAKC,yBAAyBD,EAAUP,EAAgB,CAACI,cAAaK,gBADnD,2CAAD,wD,wVAYoB,GAAfL,E,EAAAA,Y,kBAClBE,eAAa,yDAAC,WAAMC,GAAN,0GACnB,EAAKC,yBAAyBD,EAAUN,EAAgB,CAACG,iBADtC,2CAAD,wD,0VAa2C,GAAxBA,E,EAAAA,YAAaM,E,EAAAA,QACpDC,gBACE,kBAAMC,QAAQC,IAAI,oCAClB,kBAAMC,OAAYC,eAAeb,EAAmB,CAACE,cAAaM,e,sJASnCM,GACjCL,gBACE,kBAAMC,QAAQC,IAAI,0CAClB,kBACEP,gBAAc,SAAAC,GAAQ,OAAIA,EAASU,YAAYC,GAAGhB,GAAmB,SAACiB,EAAGT,GAAJ,OAAgBM,EAASN,c,4GAW5DU,G,iFACtCC,eAAS,yDAAC,WAAMd,GAAN,iGAAwBA,EAASe,QAAQC,OAAOzB,GAAgB,SAACqB,EAAD,GAAqC,IAAhCK,EAAgC,EAAhCA,QAASC,EAAuB,EAAvBA,MAAUf,EAAa,sCAC7G,OAAO,IAAIgB,SAAQ,SAAAC,GAGjB,IAAMC,EAAcH,EAIpBL,EAAeS,YAAYC,YAAYC,KAAKP,EAA5C,iCAAyDd,GAAzD,IAAkEe,WAKlElB,EAASe,QAAQJ,GAAGM,GAAS,SAACL,EAAD,GAA6B,IAAxBM,EAAwB,EAAxBA,MAAUO,EAAc,4BACpDP,IAAUG,GAAaD,EAAQK,YAd/B,mFAAD,uD,+MA8B2BzB,EAAUiB,G,0GAASd,E,+BAAU,K,kBAC1DH,EAASU,YAAYgB,OAAOnC,EAA5B,gBAA6C2B,MAAOS,iBAAQV,WAAYd,K,mJCjInF,oFAOayB,EAAW,WAAqB,IAApBnB,EAAoB,uDAAT,KAClC,GAAIoB,kBAAWpB,EAAU,OAAOA,KASrBqB,EAAe,WAAqB,IAApBrB,EAAoB,uDAAT,KACtC,GAAIsB,kBAAetB,EAAU,OAAOA,KAUzBL,EAAgB,WAAgD,IAA/C4B,EAA+C,uDAAjC,KAAMC,EAA2B,uDAAT,KAClE,OAAIJ,iBAAgBD,EAASI,GACzBD,iBAAoBD,EAAaG,QAArC,I,oCC9BF,oEAKO,IAAMJ,EAAQ,kBAAMK,GAQdH,EAAY,kBAAMG,I,oxFCJzBC,EAAO7C,EAAQ,QACf8C,EAAS9C,EAAQ,QAGjB+C,EAAa/C,EAAQ,QACrBgD,EAAehD,EAAQ,QAcvBiD,E,WACJ,aAAc,uBAKZC,KAAKC,eAAiB,IAAIJ,EAAW,CAACK,YAAaC,KAAKC,MAAM,KAAAD,KAAKE,SAA6B,QAGhGL,KAAKM,gBAAkB,GACvBN,KAAKO,iBAAmB,GACxBP,KAAKQ,mBAAqB,GAC1BR,KAAKS,2BAA6B,G,kOAWNpD,E,EAAAA,YAAaC,E,EAAAA,sB,SAEnCoD,EAAiB,KACS,OAA1BpD,E,iCAIqBwC,EAAa,IAAIa,EAAOrD,I,cAA/CoD,E,OAIAV,KAAKY,eAAe,qBAAsB,CAACvD,cAAaqD,mBACxDV,KAAKa,mBAAmB,CAACxD,cAAaqD,mB,kBAE/BA,G,6DAGTV,KAAKc,WAAW,CAACzD,cAAa0D,QAAS,8CAA+CC,MAAK,O,+TAYpE3D,E,EAAAA,YAAaK,E,EAAAA,WAGtCsC,KAAKY,eAAe,0BAA2B,CAACvD,cAAaK,gBAIzDsC,KAAKiB,kBAAkB5D,G,uBAGzB2C,KAAKkB,sBAAsB7D,G,SAId,IAAIsB,QAAJ,yDAAY,WAAMC,GAAN,iFACvB,EAAKqB,eAAekB,IAAI,EAAKF,kBAAkB5D,GAAc,CAACsC,KAAM,EAAKyB,wBAAwB,SAAAC,GAG/F,EAAKC,qBAAqB,CAACjE,cAAagE,YAGxC,IAAME,EAAO,EAAKC,gBAAgB,CAACnE,cAAaK,eAQhD,GALA2D,EAAQI,MAAMC,SAAQ,SAAAH,GAAI,OAAIA,EAAKI,cACnCN,EAAQM,SAAS,EAAGN,EAAQO,OAAOtI,OAAS,GAAG,GAGlC,OAATiI,GAAeF,EAAQQ,OAAON,EAAKO,YAAaP,EAAKQ,WAAW,GACvD,OAATR,EAAe,MAAM,IAAIS,MAAM,gDAGnCpD,OAlBqB,2CAAZ,uD,kWAgCkBvB,E,EAAAA,YAAaK,E,EAAAA,WAI9CsC,KAAKiC,6BAA6B5E,GAClC2C,KAAKkC,4BAA4B,CAC/B7E,cACAY,SAAU,WAER,IAAMsD,EAAO,EAAKC,gBAAgB,CAACnE,cAAaK,eAC1C2D,EAAU,EAAKc,oBAAoB,CAAC9E,gBAE1C,GAAIkE,GAAQF,EAAS,CAEnB,IAAM1D,EAAU,CACdN,cACAK,aACAxC,KAAMqG,EAAKrG,KACXyE,KAAM4B,EAAK5B,KACXyC,MAAOf,EAAQgB,cACf/I,OAAQiI,EAAKjI,OACbgJ,QAASjB,EAAQkB,YACjBC,SAAUjB,EAAKiB,SACfC,WAAYlB,EAAKkB,YAInBrF,OAAiBsF,2BAA2B,CAACrF,cAAaM,YAG1D,EAAKiD,eAAe,oBAAqBjD,O,sTAcvBN,E,EAAAA,Y,kBACjB,IAAIsB,QAAJ,yDAAY,WAAMC,GAAN,yFAGXyC,EAAU,EAAKc,oBAAoB,CAAC9E,gBACpCsF,EAAStB,EAAQuB,eAGvB,EAAKC,mBAAmB,CAACxF,cAAasF,WAGtCA,EAAOG,OAAO,GAAG,WAGf,IAAMC,EAAM,oBAAH,OAAuBJ,EAAOK,UAAUC,MAGjD,EAAKrC,eAAe,2BAA4B,CAACmC,MAAKJ,SAAQtF,gBAG9DuB,EAAQ,CAACmE,WAnBM,2CAAZ,wD,2SAgCW1F,E,EAAAA,Y,SACL,IAAIsB,SAAQ,SAAAC,GACvB,IAsBE,GAjBI,EAAKsE,kBAAkB,CAAC7F,kBAG1B,EAAKuD,eAAe,yBAA0B,CAC5CvD,cACAsF,OAAQ,EAAKO,kBAAkB,CAAC7F,kBAIlC,EAAK6F,kBAAkB,CAAC7F,gBAAc8F,QACtC,EAAKN,mBAAmB,CAACxF,cAAasF,OAAQ,QAIhD,EAAKV,6BAA6B,CAAC5E,gBAG/B,EAAK8E,oBAAoB,CAAC9E,gBAAe,CAG3C,IAAMsC,EAAO,EAAKwC,oBAAoB,CAAC9E,gBAAcsC,KAGrDC,EAAOD,GAAM,WAGX,EAAKiB,eAAe,kBAAmB,CAACvD,cAAasC,SAIrD,EAAKwC,oBAAoB,CAAC9E,gBAAc+F,UACxC,EAAK9B,qBAAqB,CAACjE,cAAagE,QAAS,OAGjDzC,YAIFA,IAGF,MAAOoC,GACP,EAAKF,WAAW,CAACzD,cAAa0D,QAAS,6DAA8DC,c,yLAczD,IAA9B3D,EAA8B,EAA9BA,YAAaqD,EAAiB,EAAjBA,eAC/BV,KAAKM,gBAAgBjD,GAAeqD,I,8CAUO,IAAvBrD,EAAuB,EAAvBA,YAAagE,EAAU,EAAVA,QACjCrB,KAAKQ,mBAAmBnD,GAAegE,I,4CAWC,IAAtBhE,EAAsB,EAAtBA,YAAasF,EAAS,EAATA,OAC/B3C,KAAKO,iBAAiBlD,GAAesF,I,qDAWc,IAAxBtF,EAAwB,EAAxBA,YAAaY,EAAW,EAAXA,SACxC+B,KAAKS,2BAA2BpD,GAAegG,YAAYpF,EAAU,O,wCAWrDZ,GAChB,OAAO2C,KAAKM,gBAAgBjD,GACxB2C,KAAKM,gBAAgBjD,GACrB,O,6CAU6B,IAAdA,EAAc,EAAdA,YACnB,OAAO2C,KAAKQ,mBAAmBnD,GAC3B2C,KAAKQ,mBAAmBnD,GACxB,O,yCAYqC,IAA1BA,EAA0B,EAA1BA,YAAaK,EAAa,EAAbA,WACtB2D,EAAUrB,KAAKmC,oBAAoB,CAAC9E,gBAC1C,OAAIgE,GAAW3D,GAAc,EACpB2D,EAAQI,MAAM/D,GAEhB,O,2CAWwB,IAAdL,EAAc,EAAdA,YACjB,OAAO2C,KAAKO,iBAAiBlD,GACzB2C,KAAKO,iBAAiBlD,GACtB,O,4CAUJsC,EAAK2D,KAAKC,YAAOC,IAAIC,QAAQ,QAASC,UAAKC,MAAMC,S,4CAU7BvG,GAChB2C,KAAKQ,oBAAsBR,KAAKQ,mBAAmBnD,KAGrD2C,KAAKQ,mBAAmBnD,GAAa+F,UACrCpD,KAAKQ,mBAAmBnD,QAAewG,EAGvC7D,KAAKY,eAAe,kCAAmC,CAACvD,mB,mDAU/BA,GACvB2C,KAAKS,2BAA2BpD,IAClCyG,cAAc9D,KAAKS,2BAA2BpD,M,mCAYW,6DAAJ,GAA7CA,EAAiD,EAAjDA,YAAiD,IAApC0D,eAAoC,MAA1B,KAA0B,MAApBC,aAAoB,MAAZ,KAAY,EAC3DnD,QAAQmD,MAAM,gBAAiB,CAAC3D,cAAa2D,QAAOD,c,qCAUvCgD,EAAMpG,GACnBE,QAAQC,IAAIiG,EAAMC,eAAMC,eAAUtG,S,KAMhCuG,EAAmB,IAAInE,EAWvBoE,EAA2B,WAC/BjG,iBAAYC,GAAGnB,OAAf,yDAA+B,WAAOoB,EAAP,uGAAWM,EAAX,EAAWA,MAAOrB,EAAlB,EAAkBA,YAAaC,EAA/B,EAA+BA,sBAA/B,SAIA4G,EAAiBE,uBAAuB,CAAC/G,cAAaC,0BAJtD,OAIvBoD,EAJuB,OAQ7BxC,iBAAYc,KAAKhC,OAAgB,CAACK,cAAaqD,iBAAgBhC,UARlC,2CAA/B,0DAuBI2F,EAA2B,WAC/BnG,iBAAYC,GAAGlB,OAAf,yDAA+B,WAAOmB,EAAP,yGAAWM,EAAX,EAAWA,MAAOrB,EAAlB,EAAkBA,YAAaK,EAA/B,EAA+BA,WAA/B,SAIvBwG,EAAiBI,oBAAoB,CAACjH,cAAaK,eAJ5B,uBAKvBwG,EAAiBK,4BAA4B,CAAClH,cAAaK,eALpC,uBAQTwG,EAAiBM,mBAAmB,CAACnH,gBAR5B,gBAQtB0F,EARsB,EAQtBA,IAIP7E,iBAAYc,KAAK/B,OAAgB,CAACI,cAAa0F,MAAKrE,QAAOhB,eAZ9B,4CAA/B,0DAsBI+G,EAA2B,WAC/BvG,iBAAYC,GAAGjB,OAAf,yDAA+B,WAAOkB,EAAP,mGAAWM,EAAX,EAAWA,MAAOrB,EAAlB,EAAkBA,YAAlB,SAGvB6G,EAAiBQ,aAAa,CAACrH,gBAHR,OAO7Ba,iBAAYc,KAAK9B,OAAgB,CAACG,cAAaqB,UAPlB,2CAA/B,0DAaFyF,IACAE,IACAI,K,gECxfA,gFAKO,IAAME,EAAS,iBAAuB,YAAjBjF,EAAQkF,MAQvBC,EAAa,iBAAuB,aAAjBnF,EAAQkF,Q,gICX3BE,EAAY,YACZC,EAAgB,gBAChBC,EAAoB,oBACpBC,EAAuB,uBAEflH,E,+GAQjBmH,gBACE,SAAA1H,GAAQ,OAAIA,EAASe,QAAQJ,GAAG2G,GAAW,kBAAMtH,EAASgG,IAAI2B,uBAC9D,SAAA3H,GAAQ,OAAIA,EAASU,YAAYc,KAAK8F,Q,wCAWD,IAAlBM,EAAkB,uDAAN,KACjCF,gBACE,SAAA1H,GAAQ,OAAIA,EAASe,QAAQJ,GAAG6G,GAAmB,kBAAMI,EAAUC,qBACnE,SAAA7H,GAAQ,OAAIA,EAASU,YAAYc,KAAKgG,Q,4CAUO,IAAtBM,EAAsB,uDAAN,KACzCJ,gBACE,SAAA1H,GAAQ,OAAIA,EAASe,QAAQJ,GAAG8G,GAAsB,kBAAMK,EAAcD,qBAC1E,SAAA7H,GAAQ,OAAIA,EAASU,YAAYc,KAAKiG,Q,qCAWpBxG,EAASd,GAC7BJ,gBAAc,SAAAC,GAAQ,OAAIA,EAASU,YAAYc,KAAK+F,EAAe,CAACtG,UAASd,iB,8CASjC,IAAjB4H,EAAiB,uDAAJ,GACxCjH,gBAAU,SAAAd,GACRA,EAASe,QAAQJ,GAAG4G,GAAe,SAAC3G,GAAsC,6DAAP,GAA3BK,EAAkC,EAAlCA,QAAkC,IAAzBd,eAAyB,MAAf,KAAe,EACxE4H,EAAW7D,SAAQ,SAAA0D,GAAS,OAC1BA,EAAUtG,YAAYC,YAAYC,KAAKP,EAAvC,kBAAoDd,iB,KCnE/C6H,U,kCCFf,kIAKMhI,EAAW+B,iBAAczC,EAAQ,QAAc,KAQxCoI,EAAe,SAACO,EAAcC,GACzC,OAAIf,iBAAiBrG,EAAUmH,GAC3BZ,iBAAqBtH,EAAcmI,QAAvC,GASWpH,EAAY,SAACL,GACxB,GAAI0G,iBAAU,OAAO1G,EAAST,IASnBD,EAAgB,SAACU,GAC5B,GAAI4G,iBAAc,OAAO5G,EAAST","file":"js/torrents.c0d01166.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"torrents\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/anilibrix/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([1,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import Vue from 'vue'\n\n// Create and export event bus\nexport const EventBus = new Vue();\n\n// Add bus to vue prototype\nVue.prototype.$bus = EventBus;\n","module.exports = require(\"webtorrent\");","// Utils\nimport {v4 as uuid} from 'uuid'\n\n// Resolvers\nimport {runInMain, runInRenderer} from \"@@/utils/resolvers/system/processResolver\";\n\n// Event Bus\nimport {EventBus} from \"@plugins/vue-event-bus\";\nimport AppResolver from \"@@/utils/resolvers/app\";\nimport {runOnPlatform} from \"@@/utils/resolvers/system/deviceResolver\";\n\n// Events\nexport const TORRENTS_EVENT = 'torrents:event';\nexport const TORRENTS_PARSE = 'torrents:parse';\nexport const TORRENTS_START = 'torrents:start';\nexport const TORRENTS_CLEAR = 'torrents:clear';\nexport const TORRENTS_PROGRESS = 'torrents:progress';\n\nexport default class TorrentsResolver {\n\n  /**\n   * Parse torrent\n   * Parse torrent id and torrent file content as buffer\n   *\n   * @param torrents_id\n   * @param torrents_file_content\n   * @return {Promise}\n   */\n  static async parseTorrent({torrents_id, torrents_file_content} = {}) {\n    return runInRenderer(async electron =>\n      this._sendTorrentsWindowEvent(electron, TORRENTS_PARSE, {torrents_id, torrents_file_content})\n    )\n  }\n\n\n  /**\n   * Start torrent\n   * Provide torrent id and file index to start local server\n   *\n   * @param torrents_id\n   * @param file_index\n   * @return {Promise}\n   */\n  static async startTorrent({torrents_id, file_index} = {}) {\n    return runInRenderer(async electron =>\n      this._sendTorrentsWindowEvent(electron, TORRENTS_START, {torrents_id, file_index})\n    )\n  }\n\n\n  /**\n   * Destroy torrent\n   *\n   * @param torrents_id\n   * @return {Promise}\n   */\n  static async clearTorrent({torrents_id} = {}) {\n    return runInRenderer(async electron =>\n      this._sendTorrentsWindowEvent(electron, TORRENTS_CLEAR, {torrents_id})\n    )\n  }\n\n\n  /**\n   * Emit torrent watcher event\n   *\n   * @param torrents_id\n   * @param payload\n   * @return {Promise<void>}\n   */\n  static async emitTorrentProgressWatcher({torrents_id, payload} = {}) {\n    runOnPlatform(\n      () => console.log('TODO: torrent progress on web'),\n      () => AppResolver.broadcastEvent(TORRENTS_PROGRESS, {torrents_id, payload})\n    );\n  }\n\n  /**\n   * Catch torrent watcher event\n   *\n   * @param callback\n   */\n  static catchTorrentProgressWatcher(callback) {\n    runOnPlatform(\n      () => console.log('TODO: catch torrent progress on web'),\n      () =>\n        runInRenderer(electron => electron.ipcRenderer.on(TORRENTS_PROGRESS, (e, payload) => callback(payload)))\n    )\n  }\n\n\n  /**\n   * Resolve torrents window event\n   *\n   * @param TorrentsWindow\n   * @return {void}\n   */\n  static async resolveTorrentsWindowEvent(TorrentsWindow) {\n    runInMain(async electron => await electron.ipcMain.handle(TORRENTS_EVENT, (e, {channel, token, ...payload}) => {\n      return new Promise(resolve => {\n\n        // Save original event token\n        const event_token = token;\n\n        // Set event to torrent\n        // Send event token\n        TorrentsWindow.getWindow().webContents.send(channel, {...payload, token});\n\n        // Catch event from torrents window\n        // Listen to provided channel\n        // Check event response token\n        electron.ipcMain.on(channel, (e, {token, ...response}) => {\n          if (token === event_token) resolve(response);\n        })\n      });\n    }))\n  }\n\n\n  /**\n   * Send event\n   *\n   * @param electron\n   * @param channel\n   * @param payload\n   * @return {Promise<any>}\n   * @private\n   */\n  static async _sendTorrentsWindowEvent(electron, channel, payload = null) {\n    return electron.ipcRenderer.invoke(TORRENTS_EVENT, {token: uuid(), channel, ...payload})\n  }\n\n}\n","import {isWeb, isDesktop} from \"@@/utils/states/deviceStates\";\n\n/**\n * Execute callback only on web\n *\n * @param callback\n */\nexport const runOnWeb = (callback = null) => {\n  if (isWeb() && callback) return callback();\n};\n\n\n/**\n * Execute callback only on desktop\n *\n * @param callback\n */\nexport const runOnDesktop = (callback = null) => {\n  if (isDesktop() && callback) return callback();\n};\n\n\n/**\n * Execute callbacks only on relevant platforms\n *\n * @param webCallback\n * @param desktopCallback\n */\nexport const runOnPlatform = (webCallback = null, desktopCallback = null) => {\n  if (isWeb()) return runOnWeb(webCallback);\n  if (isDesktop()) return runOnDesktop(desktopCallback);\n};\n","/**\n * Is web build\n *\n * @return {boolean}\n */\nexport const isWeb = () => process.env.IS_WEB === true;\n\n\n/**\n * Is desktop build\n *\n * @return {boolean}\n */\nexport const isDesktop = () => process.env.IS_DESKTOP === true;\n","/* webpackChunkName: \"torrents-ch\" */\n\n// To keep the UI snappy, we run WebTorrent in its own hidden window, a separate\n// process from the main window.\n\n// Electron\nimport {remote, ipcRenderer} from 'electron'\n\n// System Utils\nconst path = require('path');\nconst rimraf = require('rimraf');\n\n// WebTorrent Utils\nconst WebTorrent = require('webtorrent');\nconst ParseTorrent = require('parse-torrent');\n\n// Utils\nimport {meta} from '@@/package'\nimport {parse, stringify} from 'flatted'\n\n// Resolvers\nimport TorrentsResolver, {\n  TORRENTS_CLEAR,\n  TORRENTS_PARSE,\n  TORRENTS_START\n} from \"@@/utils/resolvers/torrents/torrentsResolver\";\n\n\nclass Torrents {\n  constructor() {\n\n    // Create WebTorrentClient\n    // Connect to the WebTorrent and BitTorrent networks. WebTorrent Desktop is a hybrid\n    // client, as explained here: https://webtorrent.io/faq\n    this.torrent_client = new WebTorrent({torrentPort: Math.floor(Math.random() * (60000 - 12000) + 12000)});\n\n    // Collections\n    this.torrents_parsed = {}; // Parsed torrents collection\n    this.torrents_servers = {}; // Servers instances for torrents\n    this.torrents_instances = {}; // Torrents instances\n    this.torrents_progress_watchers = {}; // Update handlers\n\n  }\n\n\n  /**\n   * Parse torrent from file\n   *\n   * @param torrents_id\n   * @param torrents_file_content\n   */\n  async parseTorrentFromBuffer({torrents_id, torrents_file_content}) {\n    try {\n      let torrent_parsed = null;\n      if (torrents_file_content !== null) {\n\n        // If blob is provided -> try to create buffer with torrent file\n        // Try to parse torrent\n        torrent_parsed = await ParseTorrent(new Buffer(torrents_file_content));\n\n        // Save torrent data to store\n        // Show in console parsed torrent\n        this._sendToConsole('Torrent is parsed!', {torrents_id, torrent_parsed});\n        this._saveTorrentParsed({torrents_id, torrent_parsed});\n\n        return torrent_parsed;\n      }\n    } catch (error) {\n      this._sendError({torrents_id, message: 'Произошла ошибка при парсинге торрент-файла', error});\n    }\n  }\n\n\n  /**\n   * Start torrent file\n   *\n   * @param torrents_id\n   * @param file_index\n   * @return {Promise}\n   */\n  async startTorrentForFile({torrents_id, file_index}) {\n\n    // Show in console\n    this._sendToConsole('Start torrent for file!', {torrents_id, file_index});\n\n    // Check if torrent is exists and parsed\n    // Get parsed torrent from store\n    if (this._getTorrentParsed(torrents_id)) {\n\n      // Destroy torrent if it already added\n      this._clearTorrentInstance(torrents_id);\n\n      // Add torrent\n      // Resolve promise when torrent is ready and saved to started torrents collection\n      return await new Promise(async resolve => {\n        this.torrent_client.add(this._getTorrentParsed(torrents_id), {path: this._getTorrentFilepath()}, torrent => {\n\n          // Save torrent instance to store\n          this._saveTorrentInstance({torrents_id, torrent});\n\n          // Get file with provided file index\n          const file = this._getTorrentFile({torrents_id, file_index});\n\n          // Deselect all files initial download\n          torrent.files.forEach(file => file.deselect());\n          torrent.deselect(0, torrent.pieces.length - 1, false);\n\n          // Select file with provided index\n          if (file !== null) torrent.select(file._startPiece, file._endPiece, false);\n          if (file === null) throw new Error('Файл с таким порядковым номером не обнаружен');\n\n          // Resolve started torrent\n          resolve();\n        });\n      });\n    }\n  }\n\n\n  /**\n   * Start torrent progress watcher\n   *\n   * @param torrents_id\n   * @param file_index\n   * @return {Promise}\n   */\n  async startTorrentProgressWatcher({torrents_id, file_index}) {\n\n    // Clear previous interval\n    // Create torrent download data watcher\n    this._clearTorrentProgressWatcher(torrents_id);\n    this._saveTorrentProgressWatcher({\n      torrents_id,\n      callback: () => {\n\n        const file = this._getTorrentFile({torrents_id, file_index});\n        const torrent = this._getTorrentInstance({torrents_id});\n\n        if (file && torrent) {\n\n          const payload = {\n            torrents_id,\n            file_index,\n            name: file.name,\n            path: file.path,\n            speed: torrent.downloadSpeed,\n            length: file.length,\n            seeding: torrent.uploadSpeed,\n            progress: file.progress,\n            downloaded: file.downloaded,\n          };\n\n          // Emit torrent watcher\n          TorrentsResolver.emitTorrentProgressWatcher({torrents_id, payload});\n\n          // Sent to console\n          this._sendToConsole('Torrent progress:', payload);\n\n        }\n      }\n    });\n  }\n\n\n  /**\n   * Start torrent server\n   *\n   * @param torrents_id\n   * @return {Promise}\n   */\n  async startTorrentServer({torrents_id}) {\n    return new Promise(async resolve => {\n\n      // Create new server\n      const torrent = this._getTorrentInstance({torrents_id});\n      const server = torrent.createServer();\n\n      // Save server instance to store\n      this._saveTorrentServer({torrents_id, server});\n\n      // Start server\n      server.listen(0, () => {\n\n        // Create server url\n        const url = `http://localhost:${server.address().port}`;\n\n        // Show in console\n        this._sendToConsole('Started Torrent Server: ', {url, server, torrents_id});\n\n        // Resolve url\n        resolve({url});\n      })\n    });\n  }\n\n\n  /**\n   * Destroy torrent\n   * Destroy server\n   * Clear torrent data\n   *\n   * @return Promise\n   */\n  async clearTorrent({torrents_id}) {\n    return await new Promise(resolve => {\n      try {\n\n        // Destroy server\n        // Close server\n        // Clear server for provided torrent in storage\n        if (this._getTorrentServer({torrents_id})) {\n\n          // Show in console\n          this._sendToConsole('Destroy Torrent Server', {\n            torrents_id,\n            server: this._getTorrentServer({torrents_id})\n          });\n\n          // Stop and destroy server\n          this._getTorrentServer({torrents_id}).close();\n          this._saveTorrentServer({torrents_id, server: null});\n        }\n\n        // Destroy started torrent watcher\n        this._clearTorrentProgressWatcher({torrents_id});\n\n        // Destroy torrent\n        if (this._getTorrentInstance({torrents_id})) {\n\n          // Torrent files path\n          const path = this._getTorrentInstance({torrents_id}).path;\n\n          // Remove files from fs\n          rimraf(path, () => {\n\n            // Show in console\n            this._sendToConsole('Destroy Torrent', {torrents_id, path});\n\n            // Destroy torrent\n            // Clear storage\n            this._getTorrentInstance({torrents_id}).destroy();\n            this._saveTorrentInstance({torrents_id, torrent: null});\n\n            // Resolve destroy event\n            resolve();\n          });\n\n        } else {\n          resolve();\n        }\n\n      } catch (error) {\n        this._sendError({torrents_id, message: 'Произошла ошибка при остановке и уничтожении торрент-файла', error});\n      }\n    });\n  };\n\n\n  /**\n   * Save parsed torrent to collection\n   *\n   * @param torrents_id\n   * @param torrent_parsed_data\n   * @return {void}\n   * @private\n   */\n  _saveTorrentParsed({torrents_id, torrent_parsed}) {\n    this.torrents_parsed[torrents_id] = torrent_parsed;\n  }\n\n  /**\n   * Save started torrent\n   *\n   * @param torrents_id\n   * @param torrent\n   * @private\n   */\n  _saveTorrentInstance({torrents_id, torrent}) {\n    this.torrents_instances[torrents_id] = torrent;\n  }\n\n\n  /**\n   * Save started torrent server\n   *\n   * @param torrents_id\n   * @param server\n   * @private\n   */\n  _saveTorrentServer({torrents_id, server}) {\n    this.torrents_servers[torrents_id] = server;\n  }\n\n\n  /**\n   * Create started torrent watcher\n   *\n   * @param torrents_id\n   * @param callback\n   * @private\n   */\n  _saveTorrentProgressWatcher({torrents_id, callback}) {\n    this.torrents_progress_watchers[torrents_id] = setInterval(callback, 2000);\n  }\n\n\n  /**\n   * Get parsed torrent from collection\n   *\n   * @param torrents_id\n   * @return {*}\n   * @private\n   */\n  _getTorrentParsed(torrents_id) {\n    return this.torrents_parsed[torrents_id]\n      ? this.torrents_parsed[torrents_id]\n      : null;\n  }\n\n  /**\n   * Get started torrent from collection\n   *\n   * @param torrents_id\n   * @return {*}\n   * @private\n   */\n  _getTorrentInstance({torrents_id}) {\n    return this.torrents_instances[torrents_id]\n      ? this.torrents_instances[torrents_id]\n      : null;\n  }\n\n\n  /**\n   * Get torrent file\n   *\n   * @param torrents_id\n   * @param file_index\n   * @return {*}\n   * @private\n   */\n  _getTorrentFile({torrents_id, file_index}) {\n    const torrent = this._getTorrentInstance({torrents_id});\n    if (torrent && file_index >= 0) {\n      return torrent.files[file_index];\n    }\n    return null;\n  }\n\n\n  /**\n   * Get started server\n   *\n   * @param torrents_id\n   * @return {*}\n   * @private\n   */\n  _getTorrentServer({torrents_id}) {\n    return this.torrents_servers[torrents_id]\n      ? this.torrents_servers[torrents_id]\n      : null;\n  }\n\n\n  /**\n   * Get torrent path in temp folder\n   *\n   * @type {string}\n   */\n  _getTorrentFilepath() {\n    path.join(remote.app.getPath('temp'), meta.build.appId);\n  }\n\n\n  /**\n   * Remove torrent if it was already started before\n   *\n   * @param torrents_id\n   * @private\n   */\n  _clearTorrentInstance(torrents_id) {\n    if (this.torrents_instances && this.torrents_instances[torrents_id]) {\n\n      // Destroy and clear\n      this.torrents_instances[torrents_id].destroy();\n      this.torrents_instances[torrents_id] = undefined;\n\n      // Show in console\n      this._sendToConsole('Destroy already started torrent', {torrents_id});\n    }\n  }\n\n  /**\n   * Clear started torrent watcher\n   *\n   * @param torrents_id\n   * @private\n   */\n  _clearTorrentProgressWatcher(torrents_id) {\n    if (this.torrents_progress_watchers[torrents_id]) {\n      clearInterval(this.torrents_progress_watchers[torrents_id]);\n    }\n  }\n\n\n  /**\n   * Send torrent error\n   *\n   * @param torrents_id\n   * @param message\n   * @param error\n   */\n  _sendError({torrents_id, message = null, error = null} = {}) {\n    console.error('Torrent Error', {torrents_id, error, message});\n  };\n\n\n  /**\n   * Send to console\n   *\n   * @param text\n   * @param payload\n   */\n  _sendToConsole(text, payload) {\n    console.log(text, parse(stringify(payload)));\n  }\n\n}\n\n// Initialize torrents class\nconst TorrentsInstance = new Torrents();\n\n\n/**\n * Resolve torrent parse\n * Listen to TORRENTS_PARSE event from main process\n * Try to parse data for provided torrent\n * Send event back to main with parsed data\n *\n * @return {void}\n */\nconst resolveTorrentParseEvent = () => {\n  ipcRenderer.on(TORRENTS_PARSE, async (e, {token, torrents_id, torrents_file_content}) => {\n\n    // Try to parse torrent from provided file\n    // Stringify and parse torrent data (to clear prototypes)\n    const torrent_parsed = await TorrentsInstance.parseTorrentFromBuffer({torrents_id, torrents_file_content});\n\n    // Send event back with torrent parsed data\n    // Provide event token\n    ipcRenderer.send(TORRENTS_PARSE, {torrents_id, torrent_parsed, token});\n\n  });\n};\n\n\n/**\n * Resolve torrent start event\n * Listen TORRENTS_START event from main process\n * Try to start torrent for provided file\n * Try to start torrent server\n * Also start torrent file watcher\n *\n * @return {void}\n */\nconst resolveTorrentStartEvent = () => {\n  ipcRenderer.on(TORRENTS_START, async (e, {token, torrents_id, file_index}) => {\n\n    // Start torrent for provided file index\n    // Start torrent progress watcher\n    await TorrentsInstance.startTorrentForFile({torrents_id, file_index});\n    await TorrentsInstance.startTorrentProgressWatcher({torrents_id, file_index});\n\n    // Start torrent server\n    const {url} = await TorrentsInstance.startTorrentServer({torrents_id});\n\n    // Send event back with torrent server data\n    // Provide event token\n    ipcRenderer.send(TORRENTS_START, {torrents_id, url, token, file_index});\n  })\n};\n\n\n/**\n * Resolve torrent destroy event\n *\n * @return {void}\n */\nconst resolveTorrentClearEvent = () => {\n  ipcRenderer.on(TORRENTS_CLEAR, async (e, {token, torrents_id}) => {\n\n    // Try to destroy torrent\n    await TorrentsInstance.clearTorrent({torrents_id});\n\n    // Send event back with torrent server data\n    // Provide event token\n    ipcRenderer.send(TORRENTS_CLEAR, {torrents_id, token});\n  })\n};\n\n\n// Events\nresolveTorrentParseEvent();\nresolveTorrentStartEvent();\nresolveTorrentClearEvent();\n","/**\n * Check is main process\n *\n * @return {boolean}\n */\nexport const isMain = () => process.type === 'browser';\n\n\n/**\n * Check if renderer process\n *\n * @return {boolean}\n */\nexport const isRenderer = () => process.type === 'renderer';\n","import {runInMain, runInProcess, runInRenderer} from \"@@/utils/resolvers/system/processResolver\";\n\nexport const APP_ABOUT = 'app:about';\nexport const APP_BROADCAST = 'app:broadcast';\nexport const APP_DEVTOOLS_MAIN = 'app:devtools:main';\nexport const APP_DEVTOOLS_TORRENT = 'app:devtools:torrent';\n\nexport default class AppResolver {\n\n  /**\n   * Show app about\n   *\n   * @return {void}\n   */\n  static showAbout() {\n    runInProcess(\n      electron => electron.ipcMain.on(APP_ABOUT, () => electron.app.showAboutPanel()),\n      electron => electron.ipcRenderer.send(APP_ABOUT),\n    );\n  }\n\n\n  /**\n   * Show app devtools\n   *\n   * @param AppWindow\n   * @return {void}\n   */\n  static showAppDevtools(AppWindow = null) {\n    runInProcess(\n      electron => electron.ipcMain.on(APP_DEVTOOLS_MAIN, () => AppWindow.showDevTools()),\n      electron => electron.ipcRenderer.send(APP_DEVTOOLS_MAIN),\n    );\n  }\n\n  /**\n   * Show torrent devtools\n   *\n   * @param TorrentWindow\n   * @return {void}\n   */\n  static showTorrentDevtools(TorrentWindow = null) {\n    runInProcess(\n      electron => electron.ipcMain.on(APP_DEVTOOLS_TORRENT, () => TorrentWindow.showDevTools()),\n      electron => electron.ipcRenderer.send(APP_DEVTOOLS_TORRENT),\n    );\n  }\n\n\n  /**\n   * Broadcast event\n   *\n   * @param channel\n   * @param payload\n   */\n  static broadcastEvent(channel, payload) {\n    runInRenderer(electron => electron.ipcRenderer.send(APP_BROADCAST, {channel, payload}));\n  }\n\n\n  /**\n   * Resolve broadcast event\n   *\n   * @param AppWindows\n   */\n  static resolveBroadcastEvent(AppWindows = []) {\n    runInMain(electron => {\n      electron.ipcMain.on(APP_BROADCAST, (e, {channel, payload = null} = {}) => {\n        AppWindows.forEach(AppWindow =>\n          AppWindow.getWindow().webContents.send(channel, {...payload})\n        );\n      });\n    })\n  }\n\n}\n","import appResolver from './appResolver'\n\nexport default appResolver\n","import {isDesktop} from \"@@/utils/states/deviceStates\";\nimport {isMain, isRenderer} from \"@@/utils/states/processStates\";\n\n// Require electron\n// Only on desktop process\nconst electron = isDesktop() ? require('electron') : null;\n\n/**\n * Run\n *\n * @param mainCallback\n * @param rendererCallback\n */\nexport const runInProcess = (mainCallback, rendererCallback) => {\n  if (isMain()) return runInMain(mainCallback);\n  if (isRenderer()) return runInRenderer(rendererCallback);\n};\n\n\n/**\n * Run in main\n *\n * @param callback\n */\nexport const runInMain = (callback) => {\n  if (isMain()) return callback(electron);\n};\n\n\n/**\n * Run in renderer\n *\n * @param callback\n */\nexport const runInRenderer = (callback) => {\n  if (isRenderer()) return callback(electron);\n};\n"],"sourceRoot":""}